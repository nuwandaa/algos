{"version":3,"sources":["components/MenuComponent.js","components/Spot.js","algorithms/aStar.js","algorithms/greedyBestFirstSearch.js","algorithms/uniformCostSearch.js","algorithms/randomWalkSearch.js","components/GridComponent.js","algorithms/breathFirstSearch.js","algorithms/depthFirstSearch.js","App.js","index.js"],"names":["MenuComponent","props","useState","algorithm","setAlgorithm","vel","setVel","setVelocity","algorithms","dfs","bfs","astar","greedyBfs","rw","randomWalk","ucs","className","onClick","setStartNode","setEndNode","reset","Spot","state","this","width","col","row","isEnd","isStart","isBarrier","onMouseDown","neighbors","parent","visited","distance","hScore","gScore","fScore","mouseIsPressed","onMouseEnter","onMouseUp","spotType","id","style","height","Component","listContainsObject","obj","list","i","length","heuristic","spot","endSpot","Math","abs","GridComponent","generateGrid","grid","currentRow","push","createSpot","START_SPOT_ROW","START_SPOT_COL","END_SPOT_ROW","END_SPOT_COL","h","Infinity","isClosed","isOpen","addBarrier","newGrid","slice","newSpot","addStart","addEnd","animationStarted","settingStartNode","settingEndNode","velocity","bind","resetGrid","setState","spots","path","setTimeout","animatePath","undefined","document","getElementById","startSpot","queue","start","tempCoord","shift","current","nRow","nCol","nSpot","breathFirstSearch","spotsInShortestPath","currentSpot","unshift","bfsShortestPath","animateAlgorithm","dx","dy","stack","pop","x","y","depthFirstSearch","dfsShortestPath","openList","closedList","lowerFScoreIdx","reverse","index","indexOf","splice","neighbor","bestGScore","aStarSearch","lowerHScoreIdx","greedyBestFirstSearch","lowerGScoreIdx","uniformCostSearch","randomMoves","j","floor","random","move","randomWalkSearch","opt","map","rowIdx","spotIdx","handleMouseDown","handleMouseEnter","handleMouseUp","ROWS","renderGrid","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2d68968e.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport \"./MenuComponent.css\";\n\nexport default function MenuComponent(props) {\n\n    const [algorithm, setAlgorithm] = useState('bfs');\n    const [vel, setVel] = useState(1);\n\n    const setVelocity = (vel) => {\n        props.setVelocity(vel);\n        setVel(vel);\n    };\n\n    const algorithms = {\n        dfs: props.dfs,\n        bfs: props.bfs,\n        astar: props.astar,\n        greedyBfs: props.greedyBfs,\n        rw: props.randomWalk,\n        ucs: props.ucs\n    };\n\n    return (\n        <div>\n\t        <div className=\"navbar\">\n\t        \t<button onClick={algorithms[algorithm]}>Start</button>\n\t        \t{/*{\n\t\t\t\t    props.animationStarted === false ?\n\t\t\t\t        <button onClick={algorithms[algorithm]}>Start</button> :\n\t\t\t\t        <button>Pause</button>\n\t\t\t\t}*/}\n\t\t\t\t<div className=\"dropdown\">\n\t\t\t\t    <button className=\"dropbtn\">Algorithm ⬇</button>\n\t\t\t\t    <div className=\"dropdown-content\">\n\t\t\t\t    \t<div className=\"sidedrop\">\n\t\t\t\t\t    \t<button className=\"sidedropbtn\">Uninformed &#8680;</button>\n\t\t\t\t\t    \t<div className=\"sidedrop-content\">\n\t\t\t\t\t    \t\t<button \n\t\t\t\t\t\t      \t\tclassName={ algorithm === 'bfs' ? 'active': ''} \n\t\t\t\t\t\t      \t\tonClick={()=>{setAlgorithm('bfs')}}>\n\t\t\t\t\t\t      \t\tBFS\n\t\t\t\t\t      \t\t</button>\n\t\t\t\t\t      \t\t<button \n\t\t\t\t\t\t\t\t\tclassName={ algorithm === 'dfs' ? 'active': ''} \n\t\t\t\t\t\t\t\t\tonClick={()=>{setAlgorithm('dfs')}} >\n\t\t\t\t\t\t\t\t\tDFS\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\t\tclassName={ algorithm === 'ucs' ? 'active': ''} \n\t\t\t\t\t\t\t\t\tonClick={()=>{setAlgorithm('ucs')}} >\n\t\t\t\t\t\t\t\t\tUniform Cost Search\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t    \t</div>\n\t\t\t\t      \t</div>\n\t\t\t\t      \t<div className=\"sidedrop\">\n\t\t\t\t      \t\t<button className=\"sidedropbtn\">Informed &#8680;</button>\n\t\t\t\t      \t\t<div className=\"sidedrop-content\">\t\t\t      \t\t\t\n\t\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\t\tclassName={ algorithm === 'astar' ? 'active': ''} \n\t\t\t\t\t\t\t\t\tonClick={()=>{setAlgorithm('astar')}}>\n\t\t\t\t\t\t\t\t\tA *\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\t\tclassName={ algorithm === 'greedyBfs' ? 'active': ''} \n\t\t\t\t\t\t\t\t\tonClick={()=>{setAlgorithm('greedyBfs')}}>\n\t\t\t\t\t\t\t\t\tGreedy Best-First\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t      \t\t</div>\n\t\t\t\t      \t</div>\n\t\t\t\t\t\t<hr></hr>\n\t\t\t\t\t\t<button \n\t\t\t\t\t\t\tclassName={ algorithm === 'rw' ? 'active': ''} \n\t\t\t\t\t\t\tonClick={()=>{setAlgorithm('rw')}}>\n\t\t\t\t\t\t\tRandom Walk\n\t\t\t\t\t\t</button>\n\t\t\t\t  \t</div>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"dropdown\">\n\t\t\t\t    <button className=\"dropbtn\">Velocity ⬇</button>\n\t\t\t\t    <div className=\"dropdown-content\">\n\t\t\t\t      \t<button className={ vel === 0.5 ? 'active': ''} onClick={()=>{setVelocity(0.5)}}>0.5</button>\n\t\t\t\t\t\t<button className={ vel === 1 ? 'active': ''} onClick={()=>{setVelocity(1)}}>1</button>\n\t\t\t\t\t\t<button className={ vel === 2 ? 'active': ''} onClick={()=>{setVelocity(2)}}>2</button>\n\t\t\t\t  \t</div>\n\t\t\t\t</div> \t\n\t\t\t\t<button onClick={props.setStartNode}>Set Start</button>\n\t\t\t\t<button onClick={props.setEndNode}>Set End</button>\n\t\t\t\t<button onClick={props.reset}>Reset</button>\n\t\t\t</div>\n\t\t\t<div className=\"title\">\n\t\t\t\t<h2>Welcome to <span>Algos</span>, a path search visualizer</h2>\n\t\t\t\t<h4>Click any white spot to create a barrier/wall</h4>\n\t\t\t</div>\n\t\t</div>\n\n    )\n}","import React, { Component } from 'react';\nimport './Spot.css';\n\nexport default class Spot extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    render() {\n\n        const {\n            width,\n            col,\n            row,\n            isEnd,\n            isStart,\n            isBarrier,\n            neighbors,\n            parent,\n            visited,\n            distance,\n            hScore,\n            gScore,\n            fScore,\n            mouseIsPressed,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp\n        } = this.props;\n\n        const spotType = isEnd ? 'spot-end' :\n            isStart ? 'spot-start' :\n            isBarrier ? 'spot-barrier' :\n            ''\n        return (\n            <div\n            \tid={`spot-${row}-${col}`}\n            \tclassName={`spot ${spotType}`}\n                style={{width: width, height: width}}\n            \tonMouseDown={() => onMouseDown(row, col)}\n        \t\tonMouseEnter={() => onMouseEnter(row, col)}\n        \t\tonMouseUp={() => onMouseUp()}\n        \t></div>\n        )\n    }\n}","export const aStarSearch = (grid, startSpot, endSpot) => {\n    const openList = [];\n    const closedList = [];\n    openList.push(startSpot);\n\n    while (openList.length > 0) {\n\n        // Get lower f(x) -> priority spot\n        var lowerFScoreIdx = 0;\n        for (let i = 0; i < openList.length; i++) {\n            if (openList[i].fScore < openList[lowerFScoreIdx].fScore) {\n                lowerFScoreIdx = i;\n            }\n        }\n        var current = openList[lowerFScoreIdx];\n\n\n        // Found end spot, create shortest path\n        if (current === endSpot) {\n\n            var path = [];\n            while (current.parent) {\n                path.push(current);\n                current = current.parent;\n            }\n            return [closedList, path.reverse()];\n        };\n\n        // Remove from openList, push to closedList\n        const index = openList.indexOf(current);\n        if (index > -1) {\n            openList.splice(index, 1);\n        }\n        closedList.push(current);\n\n        // Get neighbors\n        const dx = [0, -1, 0, 1];\n        const dy = [1, 0, -1, 0];\n        let x = current.row;\n        let y = current.col;\n\n        for (let i = 0; i < 4; i++) {\n            if (x + dx[i] < 0 || x + dx[i] > grid.length - 1) { continue };\n            if (y + dy[i] < 0 || y + dy[i] > grid[0].length - 1) { continue; };\n\n            let neighbor = grid[x + dx[i]][y + dy[i]];\n\n            if (neighbor.visited || neighbor.isBarrier || listContainsObject(neighbor, closedList)) { continue; };\n            var gScore = current.gScore + 1;\n            var bestGScore = false;\n\n            if (!listContainsObject(neighbor, openList)) {\n                bestGScore = true;\n                neighbor.hScore = heuristic(neighbor, endSpot);\n                openList.push(neighbor);\n            } else if (gScore < neighbor.gScore) {\n                bestGScore = true;\n            }\n\n            if (bestGScore) {\n                neighbor.parent = current;\n                neighbor.gScore = gScore;\n                neighbor.fScore = neighbor.gScore + neighbor.hScore;\n            }\n        }\n\n    }\n    return [];\n}\n\n\nfunction listContainsObject(obj, list) {\n    var i;\n    for (i = 0; i < list.length; i++) {\n        if (list[i] === obj) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction heuristic(spot, endSpot) {\n    var d1 = Math.abs(spot.row - endSpot.row);\n    var d2 = Math.abs(spot.col - endSpot.col);\n    return d1 + d2;\n}","export const greedyBestFirstSearch = (grid, startSpot, endSpot) => {\n    const openList = []; // Priority queue\n    const closedList = [];\n    openList.push(startSpot);\n\n    while (openList.length > 0) {\n\n\n        // Get element with lower h score\n        var lowerHScoreIdx = 0;\n        for (let i = 0; i < openList.length; i++) {\n            if (openList[i].hScore < openList[lowerHScoreIdx].hScore) {\n                lowerHScoreIdx = i;\n            }\n        }\n        var current = openList[lowerHScoreIdx];\n\n        if (current === endSpot) {\n            var path = [];\n            while (current.parent) {\n                path.push(current);\n                current = current.parent;\n            }\n            return [closedList, path.reverse()];\n        }\n\n        const index = openList.indexOf(current);\n        if (index > -1) {\n            openList.splice(index, 1);\n        }\n        closedList.push(current);\n\n        // Get neighbors\n        const dx = [0, -1, 0, 1];\n        const dy = [1, 0, -1, 0];\n        let x = current.row;\n        let y = current.col;\n\n        for (let i = 0; i < 4; i++) {\n            if (x + dx[i] < 0 || x + dx[i] > grid.length - 1) { continue };\n            if (y + dy[i] < 0 || y + dy[i] > grid[0].length - 1) { continue; };\n\n            let neighbor = grid[x + dx[i]][y + dy[i]];\n\n            if (neighbor.visited || neighbor.isBarrier || listContainsObject(neighbor, closedList)) { continue; };\n\n            if (!listContainsObject(neighbor, openList)) {\n                neighbor.hScore = heuristic(neighbor, endSpot);\n                neighbor.parent = current;\n                openList.push(neighbor);\n            }\n        }\n    }\n}\n\nfunction listContainsObject(obj, list) {\n    var i;\n    for (i = 0; i < list.length; i++) {\n        if (list[i] === obj) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction heuristic(spot, endSpot) {\n    var d1 = Math.abs(spot.row - endSpot.row);\n    var d2 = Math.abs(spot.col - endSpot.col);\n    return d1 + d2;\n}","export const uniformCostSearch = (grid, startSpot, endSpot) => {\n    const openList = []; // Priority queue\n    const closedList = [];\n    openList.push(startSpot);\n\n    while (openList.length > 0) {\n\n        var lowerGScoreIdx = 0;\n        for (let i = 0; i < openList.length; i++) {\n            if (openList[i].gScore < openList[lowerGScoreIdx].gScore) {\n                lowerGScoreIdx = i;\n            }\n        }\n        var current = openList[lowerGScoreIdx];\n\n        if (current === endSpot) {\n\n            var path = [];\n            while (current.parent) {\n                path.push(current);\n                current = current.parent;\n            }\n            return [closedList, path.reverse()];\n        }\n\n        const index = openList.indexOf(current);\n        if (index > -1) {\n            openList.splice(index, 1);\n        }\n        closedList.push(current);\n        current.visited = true;\n\n        // Get neighbors\n        const dx = [0, -1, 0, 1];\n        const dy = [1, 0, -1, 0];\n        let x = current.row;\n        let y = current.col;\n\n        for (let i = 0; i < 4; i++) {\n            if (x + dx[i] < 0 || x + dx[i] > grid.length - 1) { continue };\n            if (y + dy[i] < 0 || y + dy[i] > grid[0].length - 1) { continue; };\n\n            let neighbor = grid[x + dx[i]][y + dy[i]];\n\n            if (neighbor.visited || neighbor.isBarrier || listContainsObject(neighbor, closedList)) { continue; };\n\n            var gScore = current.gScore + 1;\n            var bestGScore = false;\n\n            if (!listContainsObject(neighbor, openList)) {\n                bestGScore = true;\n                openList.push(neighbor);\n            } else if (gScore < neighbor.gScore) {\n                bestGScore = true;\n            }\n\n            if (bestGScore) {\n                neighbor.parent = current;\n                neighbor.gScore = gScore;\n            }\n        }\n    }\n}\n\nfunction listContainsObject(obj, list) {\n    var i;\n    for (i = 0; i < list.length; i++) {\n        if (list[i] === obj) {\n            return true;\n        }\n    }\n\n    return false;\n}","export const randomWalkSearch = (grid, startSpot, endSpot) => {\n\n    // Neighbors\n    const dx = [0, -1, 0, 1];\n    const dy = [1, 0, -1, 0];\n    let stack = [];\n    let path = [];\n    stack.push(startSpot);\n\n    while (stack.length > 0) {\n        let spot = stack.pop();\n        if (!spot.visited) {\n            // If not visited, visit it\n            spot.visited = true;\n            path.push(spot);\n\n            if (spot === endSpot) {\n                return path;\n            }\n\n            let x = spot.row;\n            let y = spot.col;\n\n            // Random move choice\n            var randomMoves = [0, 1, 2, 3];\n            for (let i = randomMoves.length - 1; i > 0; i--) {\n                const j = Math.floor(Math.random() * (i + 1));\n                [randomMoves[i], randomMoves[j]] = [randomMoves[j], randomMoves[i]];\n            }\n\n            for (let i = 0; i < 4; i++) {\n                // Check if it is inside the grid\n                let move = randomMoves[i];\n                if (x + dx[move] < 0 || x + dx[move] > grid.length - 1) { continue };\n                if (y + dy[move] < 0 || y + dy[move] > grid[0].length - 1) { continue; };\n\n                let newSpot = grid[x + dx[move]][y + dy[move]];\n                if (newSpot.visited || newSpot.isBarrier) { continue; };\n                newSpot.parent = spot;\n                stack.push(newSpot);\n            }\n        }\n    }\n    return path;\n}","import React, { Component } from 'react';\nimport MenuComponent from \"./MenuComponent\";\nimport Spot from './Spot';\nimport \"./GridComponent.css\";\nimport { breathFirstSearch, bfsShortestPath } from '../algorithms/breathFirstSearch';\nimport { depthFirstSearch, dfsShortestPath } from '../algorithms/depthFirstSearch';\nimport { aStarSearch } from '../algorithms/aStar';\nimport { greedyBestFirstSearch } from '../algorithms/greedyBestFirstSearch.js';\nimport { uniformCostSearch } from '../algorithms/uniformCostSearch';\nimport { randomWalkSearch } from '../algorithms/randomWalkSearch';\n\nconst ROWS = 20;\nconst COLS = 20;\nconst SPOT_WIDTH = 15;\nconst WIDTH = ROWS * SPOT_WIDTH;\n\nexport default class GridComponent extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            grid: [],\n            mouseIsPressed: false,\n            animationStarted: false,\n            settingStartNode: false,\n            settingEndNode: false,\n            START_SPOT_COL: 1,\n            START_SPOT_ROW: 9,\n            END_SPOT_COL: 18,\n            END_SPOT_ROW: 9,\n            velocity: 50\n        };\n\n        this.bfs = this.bfs.bind(this);\n        this.dfs = this.dfs.bind(this);\n        this.astar = this.astar.bind(this);\n        this.greedyBfs = this.greedyBfs.bind(this);\n        this.randomWalk = this.randomWalk.bind(this);\n        this.ucs = this.ucs.bind(this);\n        this.resetGrid = this.resetGrid.bind(this);\n        this.setStartNode = this.setStartNode.bind(this);\n        this.setEndNode = this.setEndNode.bind(this);\n        this.setVelocity = this.setVelocity.bind(this);\n    }\n\n    componentDidMount() {\n        const grid = this.generateGrid();\n        this.setState({ grid });\n    }\n\n    handleMouseDown(row, col) {\n        if (this.state.settingStartNode) {\n            const newGrid = this.addStart(this.state.grid, row, col);\n            this.setState({\n                grid: newGrid,\n                settingStartNode: false,\n                START_SPOT_COL: col,\n                START_SPOT_ROW: row\n            });\n        } else if (this.state.settingEndNode) {\n            const newGrid = this.addEnd(this.state.grid, row, col);\n            this.setState({\n                grid: newGrid,\n                settingEndNode: false,\n                END_SPOT_COL: col,\n                END_SPOT_ROW: row\n            });\n        } else {\n            const newGrid = this.addBarrier(this.state.grid, row, col);\n            this.setState({ grid: newGrid, mouseIsPressed: true });\n        }\n    }\n\n    handleMouseEnter(row, col) {\n        if (!this.state.settingStartNode || !this.state.settingEndNode) {\n            if (!this.state.mouseIsPressed) return;\n            const newGrid = this.addBarrier(this.state.grid, row, col);\n            this.setState({ grid: newGrid });\n        }\n    }\n\n    handleMouseUp() {\n        this.setState({ mouseIsPressed: false });\n    }\n\n    animateAlgorithm(spots, path) {\n        this.setState({ animationStarted: true });\n        for (let i = 0; i <= spots.length; i++) {\n            if (i === spots.length) {\n                setTimeout(() => {\n                    this.animatePath(path);\n                }, this.state.velocity * i);\n                return;\n            }\n            setTimeout(() => {\n                if (spots[i] !== undefined && !spots[i].isStart && !spots[i].isEnd) {\n                    const spot = spots[i];\n                    const parent = !spot.parent.isStart ? spot.parent : spot;\n                    document.getElementById(`spot-${parent.row}-${parent.col}`).className = 'spot spot-visited';\n                    document.getElementById(`spot-${spot.row}-${spot.col}`).className = 'spot spot-visiting';\n                }\n\n            }, this.state.velocity * i);\n        }\n    }\n    animatePath(path) {\n\n        for (let i = 0; i < path.length; i++) {\n            setTimeout(() => {\n                if (!path[i].isStart && !path[i].isEnd) {\n                    const spot = path[i];\n                    document.getElementById(`spot-${spot.row}-${spot.col}`).className = 'spot spot-shortest-path';\n                }\n            }, this.state.velocity * i);\n        }\n        this.setState({ animationStarted: false });\n    }\n\n    bfs() {\n        const spots = breathFirstSearch(\n            this.state.grid,\n            this.state.grid[this.state.START_SPOT_ROW][this.state.START_SPOT_COL],\n            this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]\n        );\n        const path = bfsShortestPath(spots, this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]);\n        this.animateAlgorithm(spots, path);\n    }\n\n    dfs() {\n        const spots = depthFirstSearch(\n            this.state.grid,\n            this.state.grid[this.state.START_SPOT_ROW][this.state.START_SPOT_COL],\n            this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]\n        );\n        const path = dfsShortestPath(spots, this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]);\n        this.animateAlgorithm(spots, path);\n    }\n\n    astar() {\n        const [spots, path] = aStarSearch(\n            this.state.grid,\n            this.state.grid[this.state.START_SPOT_ROW][this.state.START_SPOT_COL],\n            this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]\n        );\n        this.animateAlgorithm(spots, path);\n    }\n\n    greedyBfs() {\n        const [spots, path] = greedyBestFirstSearch(\n            this.state.grid,\n            this.state.grid[this.state.START_SPOT_ROW][this.state.START_SPOT_COL],\n            this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]\n        );\n        this.animateAlgorithm(spots, path);\n    }\n\n    ucs() {\n        const [spots, path] = uniformCostSearch(\n            this.state.grid,\n            this.state.grid[this.state.START_SPOT_ROW][this.state.START_SPOT_COL],\n            this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]\n        );\n        this.animateAlgorithm(spots, path);\n    }\n\n    randomWalk() {\n        const spots = randomWalkSearch(\n            this.state.grid,\n            this.state.grid[this.state.START_SPOT_ROW][this.state.START_SPOT_COL],\n            this.state.grid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL]\n        );\n        this.animateAlgorithm(spots, []);\n    }\n\n    setStartNode() {\n        this.setState({ settingStartNode: true });\n    }\n\n    setEndNode() {\n        this.setState({ settingEndNode: true });\n    }\n\n    setVelocity(opt) {\n        if (opt === 0.5) {\n            this.setState({ velocity: 90 });\n        } else if (opt === 1) {\n            this.setState({ velocity: 50 });\n        } else if (opt === 2) {\n            this.setState({ velocity: 10 });\n        }\n    }\n\n    resetGrid() {\n        const grid = this.generateGrid();\n        this.setState({ grid });\n        for (let i = 0; i < grid.length; i++) {\n            for (let j = 0; j < grid[i].length; j++) {\n                if (!grid[i][j].isStart && !grid[i][j].isEnd) {\n                    document.getElementById(`spot-${i}-${j}`).className = 'spot';\n                }\n            }\n        }\n    }\n\n    renderGrid() {\n        const mouseIsPressed = this.state.mouseIsPressed;\n        return (\n            this.state.grid.map((row, rowIdx) => {\n                return (\n                    row.map((spot, spotIdx) => {\n                        return (\n                            <Spot\n                            key={spotIdx}\n                            width={SPOT_WIDTH}\n                            col={spot.col}\n                            row={spot.row}\n                            isEnd={spot.isEnd}\n                            isStart={spot.isStart}\n                            isBarrier={spot.isBarrier}\n                            visited={spot.visited}\n                            distance={spot.distance}\n                            neighbors={spot.neighbors}\n                            parent={spot.parent}\n                            hScore = { spot.hScore }\n                            gScore = { spot.gScore }\n                            fScore = { spot.fScore }\n                            mouseIsPressed={mouseIsPressed}\n                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                            onMouseEnter={(row, col) =>\n                                this.handleMouseEnter(row, col)\n                            }\n                            onMouseUp={() => this.handleMouseUp()}\n                            ></Spot>\n                        )\n                    })\n                )\n            })\n        )\n    }\n    // GRID, SPOTS AND BARRIER CREATION\n    generateGrid = () => {\n        const grid = [];\n        for (let row = 0; row < ROWS; row++) {\n            const currentRow = [];\n            for (let col = 0; col < COLS; col++) {\n                currentRow.push(this.createSpot(col, row));\n            }\n            grid.push(currentRow);\n        }\n        return grid;\n    }\n\n    createSpot = (col, row) => {\n        return {\n            col,\n            row,\n            isStart: row === this.state.START_SPOT_ROW && col === this.state.START_SPOT_COL,\n            isEnd: row === this.state.END_SPOT_ROW && col === this.state.END_SPOT_COL,\n            h: Infinity,\n            isClosed: false,\n            isOpen: false,\n            isBarrier: false,\n            visited: false,\n            distance: null,\n            parent: null,\n            hScore: 0,\n            gScore: 0,\n            fScore: 0,\n            neighbors: [\n                [col, row - 1 > 0 ? row - 1 : null],\n                [col, row + 1 < ROWS ? row + 1 : null],\n                [col - 1 > 0 ? col - 1 : null, row],\n                [col + 1 < COLS ? col + 1 : null, row]\n            ]\n        };\n    }\n\n    addBarrier = (grid, row, col) => {\n        const newGrid = grid.slice()\n        const spot = newGrid[row][col];\n        if (spot.isStart || spot.isEnd) {\n            return newGrid;\n        }\n        const newSpot = {\n            ...spot,\n            isBarrier: !spot.isBarrier,\n        };\n        newGrid[row][col] = newSpot;\n        return newGrid;\n    }\n\n    addStart = (grid, row, col) => {\n        const newGrid = grid.slice()\n        newGrid[this.state.START_SPOT_ROW][this.state.START_SPOT_COL].isStart = false;\n        const spot = newGrid[row][col];\n        const newSpot = {\n            ...spot,\n            isStart: true,\n        };\n        newGrid[row][col] = newSpot;\n        return newGrid;\n    }\n\n    addEnd = (grid, row, col) => {\n        const newGrid = grid.slice()\n        newGrid[this.state.END_SPOT_ROW][this.state.END_SPOT_COL].isEnd = false;\n        const spot = newGrid[row][col];\n        const newSpot = {\n            ...spot,\n            isEnd: true,\n        };\n        newGrid[row][col] = newSpot;\n        return newGrid;\n    }\n\n\n    render() {\n        return (\n            <div>\n                <MenuComponent \n                    bfs={this.bfs} \n                    dfs={this.dfs} \n                    astar={this.astar}\n                    ucs={this.ucs}\n                    greedyBfs={this.greedyBfs}\n                    randomWalk={this.randomWalk}\n                    reset={this.resetGrid}\n                    animationStarted={this.state.animationStarted}\n                    setStartNode={this.setStartNode}\n                    setEndNode={this.setEndNode}\n                    setVelocity={this.setVelocity}\n                />\n                { this.state.settingStartNode || this.state.settingEndNode ?\n                <div className='overlay'>Select the position of the node</div>\n                : ''\n                }\n\n                <div className='grid' style={{'width': WIDTH, 'height': WIDTH}}>\n                    {this.renderGrid()}\n                </div>\n            </div>\n        )\n    }\n}","export const breathFirstSearch = (grid, startSpot, endSpot) => {\n    const queue = [];\n\n    startSpot.visited = true;\n    startSpot.distance = 0;\n    startSpot.parent = null;\n    const start = [startSpot.row, startSpot.col];\n    // const end = [endSpot.row, endSpot.col]\n\n    queue.push(start);\n    const path = [];\n\n    while (queue.length > 0) {\n\n        const tempCoord = queue.shift();\n        const row = tempCoord[0];\n        const col = tempCoord[1];\n\n        let current = grid[row][col];\n        path.push(current);\n\n        if (current === endSpot) {\n            return path;\n        }\n\n        const neighbors = [\n            { row: row - 1, col },\n            { row, col: col + 1 },\n            { row: row + 1, col },\n            { row, col: col - 1 }\n        ]\n\n        for (let i = 0; i < neighbors.length; i++) {\n            const nRow = neighbors[i].row;\n            const nCol = neighbors[i].col;\n\n            if (nRow < 0 || nRow > grid.length - 1) { continue };\n            if (nCol < 0 || nCol > grid[0].length - 1) { continue };\n            if (grid[nRow][nCol].isBarrier) { continue };\n\n            const nSpot = grid[nRow][nCol];\n\n            if (nSpot.visited) { continue };\n\n            nSpot.visited = true;\n            nSpot.distance = current.distance + 1;\n            nSpot.parent = current;\n\n            queue.push([nSpot.row, nSpot.col]);\n        }\n    }\n    return false;\n}\n\nexport const bfsShortestPath = (spots, endSpot) => {\n    const spotsInShortestPath = [];\n    let currentSpot = endSpot;\n\n    while (currentSpot !== null) {\n        spotsInShortestPath.unshift(currentSpot);\n        currentSpot = currentSpot.parent;\n    }\n\n    return spotsInShortestPath;\n}\n/*\nfunction sortSpotsByDistance(spots) {\n    spots.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n    return spots;\n}\n*/","export const depthFirstSearch = (grid, startSpot, endSpot) => {\n\n    // Neighbors\n    const dx = [0, -1, 0, 1];\n    const dy = [1, 0, -1, 0];\n    let stack = [];\n    let path = [];\n    stack.push(startSpot);\n\n    while (stack.length > 0) {\n        let spot = stack.pop();\n        if (!spot.visited) {\n            // If not visited, visit it\n            spot.visited = true;\n            path.push(spot);\n\n            if (spot === endSpot) {\n                return path;\n            }\n\n            let x = spot.row;\n            let y = spot.col;\n\n            for (let i = 0; i < 4; i++) {\n                // Check if it is inside the grid\n                if (x + dx[i] < 0 || x + dx[i] > grid.length - 1) { continue };\n                if (y + dy[i] < 0 || y + dy[i] > grid[0].length - 1) { continue; };\n\n                let newSpot = grid[x + dx[i]][y + dy[i]];\n                if (newSpot.visited || newSpot.isBarrier) { continue; };\n                newSpot.parent = spot;\n                stack.push(newSpot);\n            }\n        }\n    }\n    return path;\n}\n\n\nexport const dfsShortestPath = (spots, endSpot) => {\n    const spotsInShortestPath = [];\n    let currentSpot = endSpot;\n\n    while (currentSpot !== null) {\n        spotsInShortestPath.unshift(currentSpot);\n        currentSpot = currentSpot.parent;\n    }\n\n    return spotsInShortestPath;\n}","import './App.css';\nimport GridComponent from \"./components/GridComponent\";\n\nfunction App() {\n    return (\n        <div className=\"App\">\n      \t\t<GridComponent />\n    </div>\n    );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n    document.getElementById('root')\n);"],"sourceRoot":""}